var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SomeStructuredMatrices","category":"page"},{"location":"#SomeStructuredMatrices","page":"Home","title":"SomeStructuredMatrices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SomeStructuredMatrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SomeStructuredMatrices]","category":"page"},{"location":"#SomeStructuredMatrices.ImplicitProduct","page":"Home","title":"SomeStructuredMatrices.ImplicitProduct","text":"ImplicitProduct\n\nLazy matrix-matrix multiplication. Handles an arbitrary number of matrices multiplied together, allowing for matrix-vector multiplication by doing a sequence of multiplications with the contained vectors. Useful for low rank approximations.\n\n\n\n\n\n","category":"type"},{"location":"#SomeStructuredMatrices.optimise-Tuple{SomeStructuredMatrices.ImplicitProduct}","page":"Home","title":"SomeStructuredMatrices.optimise","text":"optimise(A :: ImplicitProduct; max_flops_per_mul=1000000000, min_stage_size=50)\n\nTry to reduce the number of matrices in order to make matrix-vector multiplication take as few floating point operations as possible. It does this by matrix multiplications, which it assumes take nmk (FMA) FLOPS to multiply a n x m matrix by a m x k one (with vectors having k=1). It does no matrix multiplications predicted to take over max_flops_per_mul steps, and will always do matrix multiplications if the resulting matrix is smaller than or the same size as min_stage_size x min_stage_size.\n\nAs ImplicitProducts are immutable, this operates out of place, returning the optimised matrix.\n\n\n\n\n\n","category":"method"}]
}
